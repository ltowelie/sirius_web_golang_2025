---
date_created: "202503080844"
tags:
licence: "See LICENCE.md in root of this repository"
author: "Зайнутдинов Тимур Маратович"
---

# Лекция про интерфейсы

Интерфейсы - единственный абстрактный тип в golang. Обычно принято заканчивать названия интерфесов на -er - например `Stringer`, `Reader`, `Writer`, `ReadCloser` и т.д. Есть исключение в стандартной библиотеке - интерфейс error.

Интерфейсы - по сути своей хранят сигнатуры методов. Чтобы тип соответствовал интерфейсу - у него должны быть реализованы все методы, описанные в интерфейсе.

-  Есть хорошая практика - описывать интерфейс там, где он будет применяться.  Исключение - интерфейсы стандартной библиотеки.

- Также нужно стремиться к тому, чтобы в интерфейсе не было много методов: например, в стандартной библиотеке большинство интерфейсов имеют в составе лишь по одному методу (есть и по два метода - обычно такие интерфейсы составные, к примеру `ReadCloser`). Это нужно для того, чтобы не переусложнять реализации этих методов - ведь тип должен будет реализовать все эти методы.
  Интерфейс с большим количеством методов нарушает как миниум один из принципов SOLID - Принцип разделения интерфейсов, ну скорее всего принцип единой ответственности.

### Пример на интерфейсе error
Интерфейс error - позволяет реализовывать свои типы ошибок - достаточно, чтобы наш тип реализовывал функцию Error() string (в базовой функциональности):
```go
type error interface {
    Error() string
}
```

```go
package main

import (
	"fmt"
)

type WrongParamsError struct {
	Message string
	Code    int
	Value   int
}

func (e *WrongParamsError) Error() string {
	return fmt.Sprintf("Ошибка: %s: %d", e.Message, e.Value)
}

func ValidateParams(count, price int) error {
	if count <= 0 {
		return &WrongParamsError{
			Message: "Неправильное количество в заказе",
			Code:    10400,
			Value:   count,
		}
	}
	if price <= 0 {
		return &WrongParamsError{
			Message: "Неправильная сумма в заказе",
			Code:    10401,
			Value:   price,
		}
	}

	// ... other logic

	return nil
}

func main() {
	err := ValidateParams(-1, 5)
	if err != nil {
		fmt.Println(err)
	}
	err = ValidateParams(11, -500)
	if err != nil {
		fmt.Println(err)
	}
	err = ValidateParams(1, 5)
	if err != nil {
		fmt.Println(err)
	}
}
```


Чем реализация интерфейсов в golang отличается от многих других языков - это утиная типизация. То есть в типе неявно указывается, что он реализует интерфейс. Если у типа набор методов, такой же как и интерфейса - то он его реализует.
Это даёт нам гибкость и при этом не нарушает типобезопасность.

### Встраивание интерфейсов
Как и структуры - интерфейсы можно встраивать друг в друга. В результате получается такой композитный интерфейс. Пример из стандартной библиотеки:

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
type ReadCloser interface {
	Reader
	Closer
}
```

Пример - тип из request - Body - как раз реализует этот интерфейс. После обработки тела запроса - нам нужно его закрыть для предотвращения утечки ресурсов.

### Принимайте интерфейсы, возвращайте конкретную реализацию
Код, принимающий интерфейс становится не зависим от конкретного типа и реализации методов этого типа. 
Например, паттерн репозиторий. Используя его мы не зависим от какой то конкретной базы данных. Без изменения кода бизнес логики можем добавлять код с использованием баз данных.

- Код принимающий интерфейсы легче тестировать
При тестировании кода, например, использующего репозиторий - нет необходимости в подключении к базе данных. Мы можем передать mock-реализацию интерфейса. Это осень упрощает создание тестов для приложения.

Пример реализации паттерна repository (упрощенного, например нет реализации миграций, не сидирования данных) - в репозитории лекции в папке `repository_example`

#### Почему возвращение интерфейсов из функции может привести к проблемам.
Если возвращать интерфейс - при обновлении его - придется обновлять все реализации этого интерфейса. 
А если возвращать конкретный тип - то можно добавлять поля и методы без изменения существующего кода.

- При возвращении интерфейса - мы теряем информацию о типе. Код, который будет использовать возвращенный интерфейс не будет знать о реализации типа. Придется приводить к конкретному типу. Это ухудшает читаемость кода и увеличивает вероятность допущения ошибок.

```go
package main

type DB interface {
	Save(id int) error
}

type SQLite struct {
	// sqlite conn
}

func (sl *SQLite) Save(id int) error {
	// realization
	return nil
}

func (sl *SQLite) Close() error {
	// realization
	return nil
}

func NewRepo() (DB, error) {
	return &SQLite{}, nil // теряем информацию о методе Close - получить доступ к нему будет возхзможно только после приведения типа
}

func main() {
	repo, err := NewRepo()
	if err != nil {
		// Обработка ошибки

	}
	// defer repo.Close() не сработает - будет ошибка, что такого метода нет
	// Поэтому все равно приходится приводить к конкретному типу
	r := repo.(*SQLite)
	defer r.Close()

	// Также при тестировании - для мока приджется реализовывать все методы возвращенного интерфейса
}
```

### Методы с получателем-значением vs указателем:  
Как выбор получателя влияет на удовлетворение интерфейсу:
 ```go
type MyType struct{}
func (m MyType) Method() {}  // Реализует интерфейс для MyType и *MyType
func (m *MyType) Method() {} // Реализует интерфейс только для *MyType
```

### Zero-value интерфейсов:
Интерфейс со значением `nil` может быть не `nil`, если его динамическое значение — `nil`, но тип не `nil`. Пример:
```go
var buf *bytes.Buffer // nil
var ioWriter io.Writer = buf // ioWriter != nil
```

На практике такое видел - часто в работе с ошибками.
Далее будет пример с интерфейсом `error` и объяснение проблемы, дополненное информацией о `errors.Is/As`

#### Интерфейсы и nil: работа с ошибками
В Go интерфейс считается `nil` **только если и его тип, и значение равны `nil`**. Это может приводить к неочевидному поведению при работе с ошибками:

```go
package main

import "fmt"

type ConfigError struct {
	Message string
}

func (e *ConfigError) Error() string {
	return "Ошибка конфигурации: " + e.Message
}

func LoadConfig() error {
	var err *ConfigError // nil-указатель

	// Возвращаем error, которая содержит:
	// Тип: *ConfigError (не nil!)
	// Значение: nil
	return err
}

func main() {
	err := LoadConfig()

	// Кажется, что ошибки нет, но...
	if err == nil {
		fmt.Println("OK")
	} else {
		fmt.Println("Произошла ошибка:", err) // Сработает эта ветка!
	}
}

```

**Что произошло:**
- `err` в `LoadConfig()` имеет тип `*ConfigError`, но значение `nil`
- Интерфейс `error` содержит:
  - Тип: `*ConfigError` (не `nil`!)
  - Значение: `nil`
- Проверка `err == nil` вернет `false`

#### Как лучше возвращать ошибки
Лучше всего возвращать `nil` напрямую, если ошибки нет, и избегать ситуаций, когда интерфейс `error` содержит nil-указатель на кастомный тип.
```go
package main

import "fmt"

type ConfigError struct {
	Message string
}

func (e *ConfigError) Error() string {
	return "Ошибка конфигурации: " + e.Message
}

func LoadConfig() error {
	// var err *ConfigError // nil-указатель - не объявляем переменную, так как в ней нет необходимости
	var permissionDenied bool // Объявлена только для примера

	// Предположим, что здесь происходит какая-то логика,
	// которая может привести к ошибке.
	if permissionDenied {
		return &ConfigError{Message: "permission denied"}
	}

	return nil
}

func main() {
	err := LoadConfig()

	// Теперь ОК
	if err == nil {
		fmt.Println("OK") // Сработает эта ветка!
	} else {
		fmt.Println("Произошла ошибка:", err)
	}
}
```
**Что изменилост и как работает сейчас:**
1. Убрана лишняя переменная `err`:  
    Больше нет неиспользуемой переменной, которая могла бы содержать nil-указатель. Это устраняет риск случайного возврата "ненастоящего nil" (интерфейс !=`nil`, значение в интерфейсе = `nil`).
2. Ошибка возвращается напрямую:  
    Если условие `somethingGoWrong` истинно, функция сразу возвращает конкретную ошибку `*ConfigError`, без промежуточных переменных.
3. Нет скрытых ошибок:  
    Если ошибки нет, функция возвращает `nil` — это явное указание на успешное выполнение.
4. Проблема nil-указателя решена:  
    Теперь интерфейс `error` либо содержит реальную ошибку (не nil), либо явный `nil`. Это исключает ситуацию, когда интерфейс `error != nil` при nil-значении внутри.
    
**Итог:**
Код стал проще - его намного легче читать, безопаснее (случайно не вернем не nil интерфейс error с пустой ошибкой) и соответствует идиоматическому Go - ошибки обрабатываются явно, а интерфейс `error` всегда корректен.

---

#### Функции errors.Is и errors.As
Ошибки можно "заворачивать" друг в друга. Это позволяет строить некую цепочку ошибок по мере выполнения кода (на мой взгляд - можно провести некую аналогию с stack trace).

Для корректной работы с вложенными ошибками в Go 1.13+ были добавлены:
- `errors.Is` — проверяет соответствие ошибки конкретному значению
- `errors.As` — проверяет соответствие ошибки конкретному типу
Они "распаковывают" всю цепочку завернутых ошибок и сравнивают по всей цепочке. 

Кастомные ошибки должны реализовать метод `Unwrap` - чтобы возвращать ошибку, которая в нее вложена.

**Пример:**
```go
package main

type ConfigError struct {
    Message string
}

func LoadConfig() error {
	// var err *ConfigError // nil-указатель - не объявляем переменную, так как в ней нет необходимости
	var permissionDenied bool // Объявлена только для примера

	// Предположим, что здесь происходит какая-то логика,
	// которая может привести к ошибке.
	if permissionDenied {
		return &ConfigError{Message: "permission denied"}
	}

	return nil
}

func main() {
    err := LoadConfig()
    
    // Неправильно! Может не сработать для обернутых ошибок
    // if err == ConfigError {...} 
    
    // Проверка с помощью errors.Is
    if errors.Is(err, &ConfigError{}) {
        fmt.Println("ConfigError occurred")
    }

    // Проверка с помощью errors.As
    var configErr *ConfigError
    if errors.As(err, &configErr) {
	    // тут о
        fmt.Println("ConfigError occurred:", configErr.Message)
    }
}
```

**Итог:**
1. `errors.Is`:
   - Рекурсивно раскрывает цепочку обернутых ошибок
   - Корректно обрабатывает случаи, когда ошибка "обертывает" nil
   - Сравнивает и тип, и значение

2. `errors.As`:
   - Проверяет соответствие типа по цепочке ошибок
   - Безопасно работает даже с nil-значениями внутри интерфейса

---

#### Когда использовать:
- Используйте `errors.Is(err, target)` вместо `err == target`
- Используйте `errors.As(err, &target)` вместо type assertion
Но следует учитывать, что в сервисах с большой нагрузкой эти функции будут накладывать дополнительные накладные расходы
- Полезно при работе с:
  - Обернутыми ошибками (`fmt.Errorf("context: %w", err)`)
  - Ошибками, которые могут быть nil по значению, но не по типу
  - Кастомными типами ошибок с дополнительными полями

**Пример обертывания:**
```go
func LoadConfig() error {
    var err *ConfigError
    if err != nil {
        return fmt.Errorf("загрузка конфига: %w", err)
    }
    return nil
}

// Проверка в коде:
if errors.Is(err, &ConfigError{}) {
    // Обрабатываем ошибку ConfigError
}
```

---

#### Подытожим
- Интерфейсы в Go могут быть "не-nil", даже если содержат nil-значение
- При работе с ошибками используйте `errors.Is/As` вместо прямых сравнений
- Это гарантирует корректную работу с:
  - Обернутыми ошибками
  - Nil-значениями, упакованными в интерфейс
  - Иерархиями кастомных ошибок
Более подробно об использовании этих функций и работе с ошибками: в статье от vk на хабре, ссылку приложил в дополнительных материалах в конце этого текста.

### Немного о внутреннем устройстве интерфейсов
В исходном коде интерфейс является структурой
```go
type iface struct {
	tab  *itab          // это указатель на структуру доплнительных данных о интерфейсе, например, список методов интерфейса
	data unsafe.Pointer // указатель на значение конкретного типа
}
```

Структуру itab тоже рекомендую изучить, но уже самостоятельно.

## Type switch
Пустой интерфейс не сообщает нам никакой информации о типе.

Для интерфейсных типов всегда лучше применять type assertion с вторым значением
```go
func AddFive(i any) { // с версии Go 1.18 появился алиас для interface{} - any
	iTyped, ok := i.(int)
	if !ok {
		return fmt.Errorf("wrong type for %v",i)
	}
	fmt.Println(iTyped + 5)
}
```

Когда в качестве значения может выступать несколько типов - лучше применять переключатель типов (type switch)
```go
type MyInt int  
  
func serializeData(i interface{}) {  
    switch j := i.(type) {  
    case nil:  
       // i равна nil, переменная j обладает типом interface{}  
    case int:  
        Fprint(os.StdOut, []byte(stc))
    case MyInt:  
       // j обладает типом MyInt  
    case io.Reader:  
       // j обладает типом io.Reader  
    case string:  
       // j обладает типом string  
    case bool, rune: // такое вряд ли понадобится на практике - обычно совместимые типы перечисляются так, например, int, int32  
       // i содержит булево значение или руну,  
       // поэтому переменная j обладает типом interface{}    default:  
       // неизвестно, что содержит переменная i, поэтому переменная j  
       // обладает типом interface{}    }  
    case Stringer:
	    s := j.String()
	    Fprint(os.StdOut, []byte(s))
    case error:
	    s := j.Error()
	    Fprint(os.StdOut, []byte(s))
}
```
Прошу обратить внимание на комментарии в коде - особенно на то, какого типа становится переменная j в разных case
- При nil и перечислениях типов в одном case - j остается типом interface{}

### Рекомендуемые ресурсы для самостоятельного изучения
- Секция про интерфейсы в effective go - https://go.dev/doc/effective_go#interfaces
- Хорошая статья на русском про интерфейсы, с внутренним их устройством - https://habr.com/ru/articles/856272/
- Статья - оригинал про интерфейсы от Russ Cox - https://research.swtch.com/interfaces (правда во время написания той статьи интерфейсы были написаны на языке Си, как и весь рантайм)
- Статья более подробно рассказывающая о Error.Is и Error.As и работу с ошибками - https://habr.com/ru/companies/vk/articles/473658/
- Набор переводов про принципы SOLID в рамках golang. Отнес сюда так как некоторые принципы хорошо ложатся на концепцию интерфейсов в golang. https://github.com/MaksimDzhangirov/practicalSolid



