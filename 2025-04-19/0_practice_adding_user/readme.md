---
date_created: "202504181219"
tags:
licence: "See LICENCE.md in root of this repository"
author: "Зайнутдинов Тимур Маратович"
---

# Практическое занятие - добавляем сущность пользователя

Задание 
Добавьте сущность пользователя `user` к `api` нашей пиццерии в группу `api/v1/`
- Эндпоинт
	- POST `register` - для регистрации (создания) нового пользователя
- Эти если успеем (их недолго делать)
	- GET `users/:id` - получение пользователя (в будущем - защищенный эндпоинт) 
	- PUT `users/:id` - обновление пользователя (в будущем - защищенный эндпоинт)
	- DELETE`users/:id` - удаление пользователя (в будущем - защищенный эндпоинт) 

# Описание полей сущности пользователь

## Используйте `gorm.Model` для автоматического заполнения этих полей
Я копирую эти поля из самой модели, когда использую `gorm`

**ID** - Уникальный идентификатор пользователя

- Тип: `uint`, автоинкрементное
- Первичный ключ в базе данных

**CreatedAt** - Дата и время создания записи

- Тип: `time.Time`
- Заполняется автоматически при создании пользователя

**UpdatedAt** - Дата и время последнего обновления записи

- Тип: `time.Time`
- Автоматически обновляется при изменении любого поля пользователя

**DeletedAt** - Дата и время "мягкого" удаления

- Тип: `gorm.DeletedAt` (`nullable`)
- Позволяет реализовать soft-delete (программное удаление без физического удаления записи)
- `NULL` для активных пользователей


## Основные поля пользователя

**Name** - Полное имя пользователя

- Тип: `string`
- Обязательное поле (вспомните про структурные теги - `binding:"required"`)
- Максимальная длина: 255 символов (тоже структурные теги `gorm`)

**Email** - Электронная почта пользователя

- Тип: `string`
- Обязательное поле (`binding:"required"`)
- Должно быть уникальным в системе (`gorm:"unique"`)
- Валидация на корректность формата email (`binding:"email"`)
- Нормализация (приведение к нижнему регистру)
- Индексируется в базе данных для быстрого поиска

**Password** - Пароль пользователя

- Тип: `string`
- Обязательное поле (`binding:"required"`)
- Минимальная длина: 8 символов (`binding:"min=8"`)
- Не возвращается в oтветах на запросы пользователя (`json:"-"`)
- Должен храниться только в хешированном виде (можно использовать алгоритм `bcrypt` - алгоритм автоматически "солит" пароль и хранит её в строке пароля)

**Role** - Роль пользователя в системе

- Тип: `string`
- Значение по умолчанию: "user" (`gorm:"default:user"`)
- Возможные значения: `user`, `admin` и, возможно, другие
- Используется для разграничения прав доступа
- Возможна реализация через `enum` 
- В идеале роли тоже должны быть динамические - храниться и добавляться в базу данных (для реализации `RBAC`)

**Active** - Статус активности пользователя

- Тип: `bool`
- Значение по умолчанию: true (`gorm:"default:true"`)
- Используется для временной блокировки пользователей без удаления
- Будет проверяться при аутентификации

**LastLogin** - Время последнего входа в систему

- Тип: `time.Time`
- Необязательное поле
- Будет обновляться при каждой успешной аутентификации

**RefreshToken** - Токен для обновления JWT

- Тип: `string`
- Не возвращается в JSON-ответах (`json:"-"`)
- Будет генерироваться при аутентификации
- Используется для получения нового access-токена без повторной аутентификации

**Phone** - Номер телефона пользователя

- Тип: string
- Обязательное поле (`binding:"required"`)
- Должно быть уникальным в системе (`gorm:"unique"`)
- Валидация формата телефонного номера (`binding:"e164"`)
- Индексируется в базе данных для быстрого поиска

## Основные требования

1. Все обязательные поля должны проходить валидацию на уровне слоя API и сервисов 
2. Пароли, токены никогда не должны возвращаться клиенту
3. Перед сохранением пароля обязательно применять хеширование с использованием соли (используем `bcrypt`)
4. Для индексируемых полей (`email`, `phone_number`) создать соответствующие индексы в базе данных
5. Для работы с ролями рекомендуется использовать константы или `enum`-подобные типы

## С чего начать

Я сам бы скорее всего так начал бы писать данную задачу:
1. Добавление моделей (лучше отдельную модель для gorm и dto между слоями на каждую операцию) и заполнения структурных тегов в ней. Все эти модели поместите в пакет `models`
2. Создания контроллера и методов к нему (взял бы уже реализованный контроллер, например, `order` и убрал бы все лишнее и далее уже заполнял своими)
3. Написание сервисного слоя (вся бизнес-логика в нём)
4. Написание слоя репозитория (для ускорения разработки используем `gorm`)

--- 
## Дополнительные материалы
- Про актуальные алгоритмы хэширования паролей (`bcrypt`, `scrypt`, `Argon2id`)