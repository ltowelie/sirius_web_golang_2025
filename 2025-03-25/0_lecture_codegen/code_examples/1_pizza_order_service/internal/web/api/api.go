// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for OrderStatus.
const (
	OrderStatusCancelled  OrderStatus = "cancelled"
	OrderStatusDelivered  OrderStatus = "delivered"
	OrderStatusInDelivery OrderStatus = "in_delivery"
	OrderStatusPending    OrderStatus = "pending"
	OrderStatusPreparing  OrderStatus = "preparing"
)

// Defines values for PizzaSize.
const (
	Large  PizzaSize = "large"
	Medium PizzaSize = "medium"
	Small  PizzaSize = "small"
)

// Defines values for GetOrdersParamsStatus.
const (
	GetOrdersParamsStatusCancelled  GetOrdersParamsStatus = "cancelled"
	GetOrdersParamsStatusDelivered  GetOrdersParamsStatus = "delivered"
	GetOrdersParamsStatusInDelivery GetOrdersParamsStatus = "in_delivery"
	GetOrdersParamsStatusPending    GetOrdersParamsStatus = "pending"
	GetOrdersParamsStatusPreparing  GetOrdersParamsStatus = "preparing"
)

// Defines values for GetOrdersParamsSort.
const (
	Asc  GetOrdersParamsSort = "asc"
	Desc GetOrdersParamsSort = "desc"
)

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error *struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

// Order defines model for Order.
type Order struct {
	CreatedAt       *time.Time         `json:"created_at,omitempty"`
	DeliveryAddress *string            `json:"delivery_address,omitempty"`
	Id              openapi_types.UUID `json:"id"`
	Pizzas          []Pizza            `json:"pizzas"`
	Status          OrderStatus        `json:"status"`
	TotalPrice      float32            `json:"total_price"`
	UpdatedAt       *time.Time         `json:"updated_at,omitempty"`
}

// OrderStatus defines model for Order.Status.
type OrderStatus string

// OrdersResponse defines model for OrdersResponse.
type OrdersResponse struct {
	Data   *[]Order `json:"data,omitempty"`
	Limit  *int     `json:"limit,omitempty"`
	Offset *int     `json:"offset,omitempty"`
	Total  *int     `json:"total,omitempty"`
}

// Pizza defines model for Pizza.
type Pizza struct {
	Name     string    `json:"name"`
	Price    *float32  `json:"price,omitempty"`
	Quantity int       `json:"quantity"`
	Size     PizzaSize `json:"size"`
}

// PizzaSize defines model for Pizza.Size.
type PizzaSize string

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// Status Фильтр по статусу заказа
	Status *GetOrdersParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Limit Количество элементов на странице
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Сортировка по времени создания
	Sort *GetOrdersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetOrdersParamsStatus defines parameters for GetOrders.
type GetOrdersParamsStatus string

// GetOrdersParamsSort defines parameters for GetOrders.
type GetOrdersParamsSort string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Получить список заказов
	// (GET /orders)
	GetOrders(c *gin.Context, params GetOrdersParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetOrders operation middleware
func (siw *ServerInterfaceWrapper) GetOrders(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrdersParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", c.Request.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sort: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOrders(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/orders", wrapper.GetOrders)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/7yWzW7bRhDHX4XY9kjLlCOljW45FIWBAg16DQxjI66UDfiV5TLwBwRYUuE4cAoDORYt",
	"gqJ9AFYxEcYfyivMvlExs/qiRaUpEPRik9zZnf/M/GZWx6wbh0kciUinrHPM0u5TEXJ6/E6pWP0k0iSO",
	"UoEfEhUnQmkpaFng8vrnbuyTsT5MBOswGWnRF4oNXBaKNOX91cVUKxn12WDgMiWeZ1IJn3Ue2yOW9nvu",
	"3D5+8kx0Ndnf+eKyH5Uv6uQowbXw97nGt16sQnxiPtdiS8sQ/dwR4zJfBPKFUIf73PeVSG20BzxMArQz",
	"Y7huOPDWjM0ZXEEJt5C7Dlw2mp7rwBVMGjttVM8PfhBRXz9lnR3Pc1koo/l706txKv2qm3bbE9+2PG9L",
	"7Dx4stVq+q0t/k3z/lardf9+u91qeZ7nMXcZUZZJvy6YRB4d2XpKLUJ6+FqJHuuwr7aXpd+e1X37EZpT",
	"tfjBrt3QtOrnbwsfXCl+iKap5jqzWYqyECuYiMhH/y5LlEi4ss8y2p+nli2yLFB1l0ddEQTCx2Ivc7C6",
	"eS0wHWse7CdKdkUlc81248GDlcT0gphrRiHIEOW1F4dFWfjEspkl/n/E5A6zlPxZIhZJr4rc20RturnJ",
	"fK75Z9fOtsBgvUCBDKWuJmmJ4EqHxr1eKqqGtXYU1Z3zagzr2tTytRZnxMNqFRn8Brk5gXf0tzQjyKtN",
	"1a721L069NfYaKPMzWSsRrFk43nGIy31YeWkHRKzAGp5RF2+UnkkVtsjDXkQ0ITzZRYylwVc2UG3jH+x",
	"9mnuKHEzDytSa2YmzpioFxNVIu0qmWgZR6zDHj7adeASrs2FY8bw0ZxADhO4hgJuoTQXDryHHK4gp/83",
	"UDrwEUpzak7NuWOGDu0o4QYK2kkGE8jhGkq4hNycQgkfMA6pKTAiwLHgOw8f7TKXvRAqtVq8htdoEoqJ",
	"iHgiWYfda3iNe9hTXD8lVrZj2ouPfUtrNR54A1N4DxOUY15BDoUZOWZIqocwhavViKYwsUFADu/sMCfF",
	"BXxwoHTMz1DCtXltRnTabIWRPsXR4a7POux7oW1ApFPxUGhS+HhN21/L89Dp1DFDZNuMzNgMzbiSbBqZ",
	"rMOeZ3Zi2iZZThnb919s7q6Btib+V5hiWc1LKEj2BPX/QqjcIC5mRPnEJFJcBARCdArFhmDsaFqNxRc9",
	"ngV6du/Me6w5u0M3dlmN3D8IylcWZCjmkK/VutygbTYOa8WtqvE+U83UnJgRlOYEs4RFtgQQqbMMInJD",
	"wvdylrqLTRTEaoM0cszcBRSc3uhjTZX3cJ7Y64daasfz7M+4SIuIuosnSSC7BPv2sxSDOV5x+68X0vJ2",
	"oxl0Jyt/UmMW5gxuzTn23JS4KswIp0DrC4qp/pyt0/I7FOT6hLQUBMpsphUIszm37YkDb2qGkKPE9v8q",
	"8Q3cmjE1FsJyay6Q56k5gxL+JqLMkAKwYeR0XaRZGHJ1iNvfYgObsXmJN6p5/ampiBOb93GGzX6ksL3B",
	"YDD4JwAA//9IpKikMAwAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
