---
date_created: "202503231743"
tags:
licence: "See LICENCE.md in root of this repository"
author: "Зайнутдинов Тимур Маратович"
---

# Лекция про генерацию кода из спецификации openapi

На обзорной лекции о подходах к разработке веб сервисов я кратко затрагивал идею о том, что можно из спецификации `openapi` генерировать код (в нашем случае на Golang).
Какие преимущества это дает (расположил по важности)?
- Самое главное на мой взгляд это то, что когда мы начинаем со спецификации - мы поддерживаем документацию к серверу в актуальном состоянии. 

С подходом генерации спецификации из аннотаций (специально оформленных комментариев) проблема актуальности стоит достаточно остро - она устаревает в тот момент, когда программист меняет код контроллеров. Это довольно часто происходит на практике. 
Изменив код, но не изменив аннотации или не перегенерировав спецификации, программист делает спецификацию api неактуальной.
- Автоматически генерируются валидации данных - программисту не нужно будет прописывать ограничения, которые указаны в спецификации
- Наглядность api - сама спецификация принята как стандарт

## Знакомство с OpenAPI  
Почти все примеры мы стараемся рассматривать на примере пиццерии. Чтобы принимать заказы, вам нужен сайт, мобильное приложение и система для курьеров. Все эти части должны общаться друг с другом через API. Но как сделать так, чтобы:  
- Разработчики не путались в параметрах запросов?  
- Клиенты не могли заказать пиццу размером "XXXXXL" или -3 (минус три) штуки?  
- Документация всегда была актуальной?  

OpenAPI — по идее это как чертеж вашего API. Вы описываете все правила в YAML файле, а потом:  
- Генерируете код сервера/клиента (клиента обычно редко генерируют, но мы сегодня и его сгенерируем - чтобы потестировать).  
- Получаете автоматическую документацию.  
- Избегаете ручных проверок данных.  

Пример без OpenAPI:
```go
// Ручная валидация в коде - нужно описывать самому, сверяясь с требованиями к API
if order.Quantity < 1 {
    return errors.New("Неверное количество")
}
```

С OpenAPI:
```yaml
quantity:
  type: integer
  minimum: 1  # Валидация описывается один раз в спецификации
```

---

### Проектирование API — Как описать пиццерию в YAML?  
Не всегда этот шаг обязателен - я уже рассказывал, что наш сервис может быть клиентом другого, например, внешнего API.

Перед написанием спецификации:  
Продумайте сценарии (часто это делает аналитик и предоставляет требования к проекту):
Например, бизнес-логика "крупными мазками"
1. Клиент создает заказ.  
2. Курьер получает список заказов на доставку.  
3. Директор пиццерии смотрит статистику.  

Вспомним из чего состоит спецификация:  
1. `paths` — URL-адреса (например, `/orders`).  
2. `components` — Переиспользуемые блоки (например - заказы, пиццы) (я бы в рамках нашего сервиса назвал это моделями или сущностями).   
3. `parameters` — Фильтры и ограничения (например, нельзя продать -3 пиццы).
На самом деле это только базовые компоненты, в самой спецификации много ралзличных элементов

Пример для эндпоинта `/orders`:  
```yaml
get: # Имя метода
  summary: Получить список заказов
  parameters:
    - name: limit # Имя параметра
      in: query # Параметр указывается в строке запроса
      schema:
        type: integer
        minimum: 1
        maximum: 100
```

---

### Генерация кода — Как из спецификации мы получаем код?  
Начнем с понятия кодогенерация.
Кодогенерация - процесс автоматического создания программного кода на основе определенных правил или шаблонов.
### Зачем это нужно в Go?
1. Избежание рутины  
    Писать вручную однотипный код для API, баз данных или валидаций — скучно и чревато ошибками.  
    Пример: Вместо ручного описания 10 структур для REST API, вы генерируете их из OpenAPI-спецификации.
    Видел опыт коллег из других организаций, где были генераторы целых бойлерплейтов проектов, например, можно написать свой генератор по паттерну репозиторий, который мы рассматривали ранее.
2. Синхронизация кода и документации  
    Если документация (например, Swagger) и код генерируются из одного источника, они никогда не разойдутся.
3. Соблюдение стандартов
    Генератор гарантирует, что все обработчики API (в смысле программного API, а не только web api) будут оформлены единообразно.

### Как это реализуется в Go?
1. Инструменты:
    - `go generate` — встроенная команда для запуска генераторов.
    - Примеры генераторов кода: 
	    - `stringer` (для методов `String()` enum'ов), входит в пакет `go-tools`
		- `oapi-codegen`, `go-swagger`, `swagger-codegen`, `ogen` (для OpenAPI)
	    - `gqlgen` (для GraphQL) - не использовал на практике
	    - `protoc-gen-go` (для gRPC) - генерация кода сервера и клиента grpc из `proto` файла, когда будете писать поддержку grpc в сервисах - будете использовать этот инструмент

#### Без кодогенерации - руками нужно прописывать
```go

type Status int

const (
    Pending Status = iota
    Delivered
)

// Нужно вручную написать метод String() и не забывать его дозаполнять при обновлении
func (s Status) String() string {
    switch s {
    case Pending: return "pending"
    case Delivered: return "delivered"
    default: return "unknown"
    }
}
```

#### С кодогенерацией - на примере
Статусы доставки пиццы:
1. Установите `stringer`:
```shell
go install golang.org/x/tools/cmd/stringer@latest
```

> С версии go 1.24 появился флаг tool для команды go get. Он скачивает и прописывает в go.mod в отдельную секцию все дополнительные инструменты
> ```shell
> go get -tool golang.org/x/tools/cmd/stringer@latest
> ```
> Если у вас версия 1.24 (на момент лекции самая новая версия) - то для установки так 


2. Создайте файл `pizza_status.go`. Добавьте комментарий - аннотацию (инструкцию, которую команда go generate прочитает)
	```go
	package enum
	
	// Ниже аннотация для команды go generate и параметры - какой генератор использовать (по идее просто каманда в shell) и, в данном случае, тип для генерации и срез префикса - чтобы в строках на было слова Status, и имя файла куда выводить

	//go:generate stringer -type=PizzaStatus -trimprefix=Status -output=pizza_status_string.go
	type PizzaStatus int
	
	const (
	    StatusPending PizzaStatus = iota + 1  // Начинаем с 1
	    StatusPreparing
	    StatusInDelivery
	    StatusDelivered
	    StatusCancelled
	)
	```
	
	- `//go:generate` - специальный комментарий для запуска генератора.
	- `-type=PizzaStatus` - тип, для которого генерируется метод.
	- `-trimprefix=Status` - удаляет префикс "Status" из строковых значений.
	- `-output` - имя файла для сохранения сгенерированного кода
	- Значения `enum` (кстати, в golang не полноценный `enum`) начинаются с 1 (`iota + 1`), чтобы избежать нулевого значения (для чего это нужно?).
3. Запустите 
	```shell
	go generate ./...
	```  
	
	- Создастся файл `pizza_status_string.go`. (Какой пакет будет?)
	- В нем будет метод `String()` для типа `PizzaStatus`.
	- `./...` используется для рекурсивного поиска go файлов в текущей папке

4. Результат 
Содержимое `pizza_status_string.go`:
```go
// Code generated by "stringer -type=PizzaStatus -trimprefix=Status -output=pizza_status_string.go"; DO NOT EDIT.  
  
package enums  
  
import "strconv"  
  
func _() {  
    // An "invalid array index" compiler error signifies that the constant values have changed.  
    // Re-run the stringer command to generate them again.    var x [1]struct{}  
    _ = x[StatusPending-1]  
    _ = x[StatusPreparing-2]  
    _ = x[StatusInDelivery-3]  
    _ = x[StatusDelivered-4]  
    _ = x[StatusCancelled-5]  
}  

// Интересный способ храннения, не правда ли?)
const _PizzaStatus_name = "PendingPreparingInDeliveryDeliveredCancelled"  
  
var _PizzaStatus_index = [...]uint8{0, 7, 16, 26, 35, 44}  
  
func (i PizzaStatus) String() string {  
    i -= 1  
    if i < 0 || i >= PizzaStatus(len(_PizzaStatus_index)-1) {  
       return "PizzaStatus(" + strconv.FormatInt(int64(i+1), 10) + ")"  
    }  
    return _PizzaStatus_name[_PizzaStatus_index[i]:_PizzaStatus_index[i+1]]  
}
```

Как использовать полученный результат?
```go
package main  
  
import (  
    "fmt"  
  
    "stringer_enums/internal/models/enums")  
  
func main() {  
    // Запустим код до генерации и после.  
    // Что будет выведено до генерации?    // Как Println понимает, что ему нужно строку напечатать?    
    fmt.Println(enums.StatusPreparing)  
    fmt.Println(enums.StatusCancelled)  
  
    //status := enums.StatusDelivered  
    //fmt.Println(status.String())  // тут можно вызвать String()?}
```

Отлично, базовую информацию по кодогенерации изучили, перейдем к теме нашей лекции - сгенерируем код http сервера и клиента из спецификации.


## Генерация из спецификации openapi

Перед запуском генерации кода:
Установите генератор `oapi-codegen`:  
```bash
go install github.com/deepmap/oapi-codegen/cmd/oapi-codegen@latest
```

>Для go 1.24+ указывал команду выше, но эта тоже сработает

Что делает генератор: 
1. **Создает структуры данных** из ваших схем.  
   ```go
   type Order struct {
       ID      string  `json:"id"`
       Pizzas []Pizza `json:"pizzas"`
   }
   ```
2. **Генерирует интерфейсы обработчиков**, которые вы должны реализовать.  
   ```go
   type ServerInterface interface {
       GetOrders(ctx context.Context, params GetOrdersParams) (*OrdersResponse, error)
   }
   ```
3. **Добавляет валидации** на основе правил из YAML.  
Тут два варианта:
- Добавить `middleware` для валидации (покажу в коде). Этот метод гораздо проще.
- Вызвать метод Validate из пакета `validator` и передать ему структуру с параметрами. Этот метод не очень удобен, так как еще нужно добавить аннотации в спецификацию и использовать расширение `x-oapi-codegen-extra-tags`


Пример команды для генерации кода на go:  
```bash
oapi-codegen -generate types,spec,gin -package api pizza_api.yaml > api.gen.go
```
сгенерируются типы, спецификация (чтобы была доступна через метод) и код для работы с `Gin`

Генератор не пишет бизнес-логику! Вы сами решаете, как получать данные из БД или считать стоимость заказа.

---

### Реализация логики — Что писать вручную?    

Пример обработчика:  
```go
type Controller struct {
}

// Реализация метода GetOrders из интерфейса
func (c *Controller) GetOrders(ctx *gin.Context, params api.GetOrdersParams) {  
    // В params приходят параметры из запроса
  
    // Тут пишем нашу бизнес логику  
    // Имитация данных    
    mockUUID := uuid.New()  
    orders := &[]api.Order{  
       {Id: mockUUID, Status: api.OrderStatusPending},  
    }  
  
    // Отправляем ответ через Gin  
    ctx.JSON(http.StatusOK, api.OrdersResponse{  
       Data: orders,  
    })  
}
```

Если метод не зарегистрировать - будет возвращаться статус 404

---

### Валидация данных — Как работают ограничения?  
Перед тестированием:  
Проверьте, как валидируются данные:  
1. На уровне API:  
   ```yaml
   Pizza:
     properties:
       size:
         enum: [small, medium, large]  # Только эти значения допустимы
   ```
2. В Go-коде:  // Todo дописать про middleware
При использовании `middleware` - он сам под капотом проверит соответствие спецификации
или (в зависимости от выбранного способа валидации)
Генератор добавит теги `validate` для библиотеки валидации (например, `go-playground/validator`).

Пример ошибки:  
Если клиент попытается отправить:  
```json
{
  "size": "extra-large",
  "quantity": 0
}
```
Сервер автоматически ответит:  
```json
{
  "error": {
    "code": 400,
    "message": "size must be one of [small, medium, large]"
  }
}
```

> Если в спецификации есть `example` - в Swagger UI будут подсказки по возможным значениям.

---
### Дополнительные возможности - напрямую не связано с генерацией в golang
#### Спецификация swagger в браузере
github.com/swaggo/gin-swagger
Помогает получить в удобном виде
- Список всех эндпоинтов.  
- Примеры запросов/ответов.  
- Возможность тестировать API прямо из браузера.  
(Думаю, что вы такое уже видели, когда писали на python, например на `fastapi`)

#### Генерация Postman-коллекции (отдельный инструмент, в стадии бета-тестирования)
https://openapi-generator.tech/docs/installation/
https://openapi-generator.tech/docs/generators/postman-collection

```bash
openapi-generator-cli generate -i pizza_api.yaml -g postman -o postman_collection
   ```

Данный инструмент не тестировал

---
## Дополнительная литература
### Про кодогенерацию
- Обзорная статья от Роба Пайка о применении генераторов (англ.) https://go.dev/blog/generate (есть перевод на хабре - https://habr.com/ru/articles/269887/)
- Проект awesome-go включает в себя в том числе генераторы https://awesome-go.com/generators/
- О создании генераторов (англ.) https://evilmartians.com/chronicles/a-taste-of-go-code-generator-magic-a-quick-guide-to-getting-started
- Кодогенератор на go, упоминается в статье выше, много реализованных вещей для генерации разного рода объектов https://github.com/dave/jennifer/
- О опыте внедрения кодогенератов в пайплайн написания сервисов https://habr.com/ru/companies/omprussia/articles/558690/

### Про генерацию спецификации
- Старая обзорная статья (не упоминается `oapi-codegen`) https://habr.com/ru/articles/496098/
- Генератор написан на java, поддерживает много языков для генерации клиентов и серверов, также может генерировать, много других штук, например, коллекцию postman, или даже схему для postgres (англ) https://github.com/OpenAPITools/openapi-generator
- Статья о генерации сервера из спецификации (англ)- https://ldej.nl/post/generating-go-from-openapi-3/
- Генерация из спецификации и подход к валидации через добавление дополнительных полей в спецификацию https://blog.commitsmart.com/go-oapi-codegen-request-validation-285398b37dc8

### Про новый тулинг с версии golang 1.24
- (англ) https://www.alexedwards.net/blog/how-to-manage-tool-dependencies-in-go-1.24-plus