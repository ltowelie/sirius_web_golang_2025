---
date_created: "202503091222"
tags: 
licence: See LICENCE.md in root of this repository
author: Зайнутдинов Тимур Маратович
---

# Лекция про конкурентность

**Определение конкурентности**  
Конкурентность в контексте вычислительных систем подразумевает декомпозицию задачи на независимые подпроцессы и организацию их безопасного взаимодействия при работе с общими данными. Это позволяет эффективно распределять ресурсы и повышать производительность программ.

> Конкурентность не есть параллелизм - Роб Пайк.
> Конкуретная программа может работать и на компьютере с одним ядром. Тем не менее на мультиядерных машинах она должна работать эффективно.

**Традиционные подходы**  
В большинстве языков программирования конкурентность реализуется через внешние библиотеки, которые задействуют потоки операционной системы. Для синхронизации данных между потоками применяются механизмы блокировок (например, мьютексы или семафоры). Однако такой подход часто сопряжён с повышенной сложностью: разработчикам необходимо вручную управлять состоянием ресурсов, избегая условий гонки (race conditions) и взаимных блокировок (deadlocks).

**Модель Go: CSP и её преимущества**  
Язык Go предлагает принципиально иную модель конкурентности, основанную на теории _взаимодействующих последовательных процессов_ (Communicating Sequential Processes, CSP). Эта концепция, впервые описанная Тони Хоаром в 1978 году (автором алгоритма быстрой сортировки), делает упор не на разделение памяти через блокировки, а на _обмен сообщениями_ между легковесными сущностями — горутинами (в случае с golang).

Ключевые особенности подхода Go:

1. **Горутины** — легковесные потоки, управляемые рантаймом Go, а не ОС. Они потребляют минимум ресурсов, позволяя создавать тысячи параллельных задач.
2. **Каналы** — тип данных, обеспечивающий безопасную передачу сообщений между горутинами. Каналы исключают необходимость явных блокировок.
3. **Оператор `select`** — механизм для обработки множества каналов, напоминающий `switch`, но адаптированный для асинхронных операций.

**Паттерны конкурентности в Go**  
Модель CSP позволяет реализовывать мощные паттерны, которые остаются интуитивно понятными. Среди них:

- Распределение задач через worker pools.
- Обработка событий с использованием fan-in/fan-out.
- Тайм-ауты и отмена операций через контексты.

> Эти паттерны разберем на практическом занятии

Несмотря на высокоуровневую абстракцию, Go также предоставляет доступ к низкоуровневым инструментам (например, пакет `sync`), которые могут быть полезны в специфических сценариях. Однако в большинстве случаев паттерны на основе CSP оказываются более надёжными и простыми в поддержке.

### Конкурентность — это не параллелизм

Конкурентность часто воспринимают как универсальный инструмент для ускорения программ, но это не всегда так. Её необдуманное применение может усложнить код без прироста производительности. Важно понимать:

- **Конкурентность != параллелизм**. Первая структурирует задачу, вторая обеспечивает одновременное выполнение на многопроцессорных системах.

- Закон Амдала (1967) показывает, что ускорение ограничено долей последовательных операций в алгоритме. Даже идеальная параллелизация не даст выигрыша, если критическая часть кода остаётся линейной. Другими словами - ваш код работает со скоростью самой медленной его части.


**Когда использовать конкурентность?**  
Любую программу можно разделить на этапы:

1. Получение данных > 2. Обработка > 3. Вывод результата.  
    Конкурентность уместна, если этапы **независимы** (например, обработка данных не требует полного завершения их сбора).

**Ограничения:**

- **Накладные расходы**: Запуск горутин и обмен данными между ними замедляют выполнение кратких задач.

- **Оптимальный сценарий**: Операции ввода-вывода (сеть, диск), где задержки в сотни раз превышают время вычислений. Для быстрых резидентных операций конкурентность часто неэффективна.

**Практические рекомендации:**

1. Начинайте с последовательной реализации.
2. Измеряйте производительность (бенчмарки) перед внедрением конкурентности.
3. Используйте её только там, где независимые задачи можно объединить без блокировок.

Конкурентность — мощный, но не универсальный инструмент. Её эффективность зависит от структуры задачи и окружения, а не от «модности» подхода.

## Реализация конкурентности в golang
Поговорим про:
- Горутины
	- Утечка горутин
- Каналы
	- Буферизированные и не буферизированные каналы
	- nil каналы
	- Кто пишет в канал - тот его и закрывает
	- Цикл for range в сочетании с каналами 
		- Чтение из канала и закрытие канала
	- Оператор select
		- Секция default
- Deadlock - взаимная блокировка горутин
- Waitgroup и Errgroup (не включен в стандартную поставку, но включен в пакет X - от команды разработчиков языка)
- Примитивы синхронизации 
	- Мьютексы
	- Атомики - lock-free структуры данных (пакет sync/atomic)

### Горутины в Go: легковесная модель конкурентности  
**Основные понятия**  
- **Процесс**: Экземпляр программы с выделенной памятью и ресурсами, управляемый ОС.  
- **Поток (thread)**: Минимальная единица выполнения внутри процесса. Потоки одного процесса разделяют его ресурсы.  
- **Горутина**: Легковесный «поток», управляемый рантаймом Go, а не ОС.  

**Чем горутины отличаются от потоков?**  
1. **Создание**:  
   - Поток ОС: Требует системных ресурсов, медленный.  
   - Горутина: Создается за наносекунды, минимальные накладные расходы.  

2. **Память**:  
   - Поток ОС: Фиксированный стек (обычно 1–8 МБ).  
   - Горутина: Динамический стек (начинается с 2 КБ, растет по необходимости).  

3. **Планирование**:  
   - Потоки ОС: Управляются ядром ОС, переключение требует системных вызовов.  
   - Горутины: Управляются планировщиком Go внутри процесса. Переключение между ними происходит без участия ОС.  

**Преимущества горутин**  
- **Масштабируемость**: Одна программа может запускать десятки тысяч горутин.  
- **Интеллектуальный планировщик**:  
  - Автоматически распределяет горутины по потокам ОС.  
  - Интегрирован со сборщиком мусора и сетевым опрашивателем (epoll/kqueue).  
  - Предотвращает блокировки ввода-вывода: если горутина ждет данных из сети, планировщик переключается на другую задачу.  

**Как использовать горутины?**  
Для запуска горутины добавьте ключевое слово `go` перед вызовом функции:  
```go
package main

import "fmt"
import "time"

func main() {
    go printNumbers() // Запуск горутины
    time.Sleep(time.Second) // Ожидание (пример!) - почему так делать не следует?
    // А как делать правильно рассмотрим далее
}

func printNumbers() {
    for i := 0; i < 10; i++ {
        fmt.Println(i)
        // Долгая операция
        time.Sleep(time.Millisecond*200)
    }
}
```
**Важно**: Горутины не имеют доступа к возвращаемым значениям функции. Для обмена данными используйте каналы (рассмотрим далее).

---

**Пример: разделение логики и конкурентности**  
```go
package main 

import "fmt"

// Бизнес-логика (не знает о конкурентности)
func process(val int) int {
    return val * 2 // Например, удвоение числа
}

// Конкурентная обертка (работает с каналами)
func runConcurrently(input <-chan int, output chan<- int) {
    go func() {
        for val := range input { // Чтение из канала
            result := process(val) // Вызов логики
            output <- result       // Запись результата
        }
    }()
}

func main() {
    input := make(chan int, 3)
    output := make(chan int, 3)

    // Запуск горутины
    runConcurrently(input, output)

    // Отправка данных
    input <- 1
    input <- 2
    input <- 3
    close(input)

    // Получение результатов
    for i := 0; i < 3; i++ {
        fmt.Println(<-output) // 2, 4, 6
    }
}
```

**Почему это важно?**  
- **Модульность**: Бизнес-логика (`process`) изолирована от конкурентности.  
- **Тестируемость**: Функцию `process` можно проверять отдельно.  
- **Безопасность**: Каналы гарантируют синхронизацию данных.  

**Когда использовать горутины?**  
- Обработка сетевых запросов.  
- Параллельные вычисления с независимыми задачами.  
- Операции ввода-вывода (чтение файлов, БД).  

### Каналы  
#### Основы
- Создание: `ch := make(chan int)` (небуф.) / `make(chan int, 10)` (буф.).  
- **Каналы — ссылочный тип**: При передаче в функции передается указатель.  
- Направленность:  
  ```go
  func read(ch <-chan int) {}   // Только чтение
  func write(ch chan<- int) {}  // Только запись
  ```

#### Типы каналов
- **Буферизированные vs небуферизированные**:  
  - Небуф.: Синхронная коммуникация (отправитель/получатель блокируются до завершения операции).  
  - Буф.: Асинхронная (блокировка только при заполнении/опустошении буфера).  Можно сравнить с очередью сообщений. FIFO.
- **nil-каналы**:  
  - Чтение/запись блокируются навсегда.  
  - Используются для "отключения" ветвей в `select`.

#### Управление каналами
- **Кто пишет — тот закрывает**: Закрытие канала — ответственность отправителя.  
- **Цикл `for range`**:  
  ```go
  for v := range ch { 
      // Обработка v 
  } // Цикл завершится при закрытии канала
  ```
- **Идиома "запятая-ok"**:  
  ```go
  v, ok := <-ch 
  if !ok { 
      // Канал закрыт 
  }
  ```
#### Частые ошибки при работе с каналами:  
   - Закрытие закрытого канала → panic.  
   - Чтение из nil-канала → вечная блокировка.  
   - Использование буферизированных каналов "на всякий случай".

#### Оператор `select`
- Обработка множества каналов:  
  ```go
  select {
  case v := <-ch1: 
      // Обработать v
  case ch2 <- data: 
      // Данные отправлены
  case <-time.After(1*time.Second):
      // Таймаут
  default: 
      // Неблокирующая логика
  }
  ```
- **Секция `default`**:  
  - Использовать осторожно! Бесконечные циклы с `default` съедают CPU.  
  - Пример применения: Неблокирующая проверка канала.
#### Взаимоблокировки (deadlocks):  
**Пример 1: Взаимоблокировка горутин**

```go
package main

import "fmt"

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    
    go func() {
        gv := 1
        ch1 <- gv       // Блокировка: ждет, пока main прочитает из ch1
        gv2 := <-ch2    // Блокировка: ждет, пока main запишет в ch2
        fmt.Println(gv, gv2)
    }()
    
    v := 2
    ch2 <- v           // Блокировка: ждет, пока горутина прочитает из ch2
    v2 := <-ch1        // Блокировка: ждет, пока горутина запишет в ch1
    fmt.Println(v, v2)
}
```

**Что происходит:**
1. Горутина пытается записать `1` в `ch1` → блокируется, пока `main` не прочитает.
2. `main` пытается записать `2` в `ch2` → блокируется, пока горутина не прочитает.
3. Обе горутины заблокированы навсегда → **deadlock**. Рантайм остановит выполнение программы и выведет сообщение об ошибке с дедлоком

---

**Пример 2: Решение через `select`**

```go
package main

import (
	"fmt"
)

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		gv := 1
		ch1 <- gv    // Запись в ch1 (не блокируется, если main читает через select)
		gv2 := <-ch2 // Чтение из ch2 после разблокировки
		fmt.Println(gv, gv2)
	}()

	v := 2
	var v2 int

	select {
	case ch2 <- v: // Попытка записи в ch2 - и запишет в канал
		fmt.Println("ch2") // Но этот код не выполнится, но в канал ch2 запись произойдет
	case v2 = <-ch1: // Если в ch1 есть данные → читаем
		fmt.Println("ch1")
	}

	fmt.Println(v, v2) // Выведет 2 1
}
```

**Как работает `select`:**
1. Горутина успевает записать `1` в `ch1` до того, как `select` в `main` начнет работу.
2. `select` видит, что в `ch1` есть данные → выполняет `v2 = <-ch1`.
3. Основная горутина разблокируется, получив `1` из `ch1`.
4. Теперь горутина может прочитать `2` из `ch2` и завершиться.

**Ключевые моменты:**
- `select` **не блокируется**, если хотя бы один канал готов.
- В примере 2 `select` выбирает чтение из `ch1`, что разрывает цикл блокировок.
- Порядок выполнения case в `select` **случаен**, но в данном случае чтение из `ch1` возможно сразу.
### Возможные состояния каналов
| Операция     | Небуф, <br>открытый                            | Небуф, закрытый                                                       | Буф, <br>открытый                                        | Буф, закрытый                                                            | Равный nil            |
| ------------ | ---------------------------------------------- | --------------------------------------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------------------ | --------------------- |
| **Чтение**   | Приостанавливает выполнение гортуны до записи  | Возвращает нулевое значение (используйте `, ok` для проверки закрытия | Приостанавливает выполнение горутины, если буфер пуст    | Возвращает значение из буфера (если пуст — нулевое, `, ok` для проверки) | Бесконечное зависание |
| **Запись**   | Приостанавливает выполнение горутины до чтения | Паника                                                                | Приостанавливает выполнение горутны, если буфер заполнен | Паника                                                                   | Бесконечное зависание |
| **Закрытие** | Работает                                       | Паника                                                                | Работает (буфер содержит значения)                       | Паника                                                                   | Паника                |


### Утечка горутин
После объяснения того, как работают каналы, хочу рассказать про утечку горутин. Ошибка не так часто встречается, но на мой взгляд допустить её довольно просто - достаточно, например забыть закрыть канал.
Сама утечка большой проблемы не представляет, но она может понести за собой другие утечки ресурсов, например файл может на закрыться после цикла по каналу или соединение.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	orders := make(chan int) // Небуферизованный канал для заказов
	
	// Запускаем горутину-курьера
	go func() {
		for order := range orders { // Будет работать, пока канал не закрыт
			fmt.Printf("Курьер принял заказ %d\n", order)
			time.Sleep(500 * time.Millisecond) // Имитация времени доставки
			fmt.Printf(">> Заказ %d доставлен!\n", order)
		}
		
		// Этот код никогда не выполнится - курьер не попадет домой
		fmt.Println("Курьер пошел домой")
	}()

	
	// Отправляем 3 заказа
	for i := 1; i <= 3; i++ {
		orders <- i
		fmt.Printf("Клиент сделал заказ %d\n", i)
	}
	
	// 
	// close(orders)
	fmt.Println("\nЗаказы закончились")
	
	time.Sleep(3 * time.Second) // Далее рассмотрим правильное ожидание завершения горутин
	fmt.Println("Пиццерия закрывается - закончился рабочий день")

	// Утечка горутины: забыли закрыть канал orders
	// Горутина курьера продолжает висеть в ожидании новых заказов, 
	// но при завершении работы приложения - планировщик горутину уже не вызовет 
}

```


---


### WaitGroup и ErrGroup  
- **`sync.WaitGroup`**:  
  ```go
  var wg sync.WaitGroup
  wg.Add(1)
  go func() {
      defer wg.Done()
      // Работа
  }()
  wg.Wait()
  ```

```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	
	ingredients := []string{"помыть и нарезать томаты", "замесить и раскатать тесто", "натереть сыр", "нарезать пепперони", "помыть и нарезать шампиньоны"}
	var wg sync.WaitGroup

	fmt.Println("Начинаем готовить пиццу!")
	wg.Add(len(ingredients)) // Хорошая практика сразу заполнять, если количество горутин заранее известно

	// Параллельная подготовка ингредиентов разными поварами
	for _, item := range ingredients {
		prepare := func(ingredient string) {
			defer wg.Done()
			timeNeeded := time.Duration(rand.Intn(1000)+500) * time.Millisecond
			fmt.Printf("Начинаем процесс - %s...\n", ingredient)
			time.Sleep(timeNeeded)
			fmt.Printf("Процесс %s - завершен!\n", ingredient)
		}
		go prepare(item)
	}

	// Ждем когда все ингредиенты будут подготовлены
	wg.Wait()
	
	fmt.Println("Все компоненты готовы! Отправляем пиццу в печь!")
	time.Sleep(500 * time.Millisecond)
	fmt.Println("Пицца готова! Приятного аппетита!")
}
```

- **`golang.org/x/sync/errgroup`**:  
  - Группа горутин с обработкой ошибок.  
  - Автоматический `Wait` и отмена при ошибке.

### Примитивы синхронизации  
#### Мьютексы
```go
var mu sync.Mutex
mu.Lock() 
// Критическая секция
mu.Unlock()
```

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var deliveries int
	var mu sync.Mutex
	var wg sync.WaitGroup

	totalOrders := 1000 // Всего заказов на доставку пиццы
	wg.Add(totalOrders)

	fmt.Println("Доставок пиццы ожидается:", totalOrders)
	// Запускаем курьеров
	for i := 0; i < totalOrders; i++ {
		go func(orderID int) {
			defer wg.Done()

			// Убираем мьютекс для демонстрации гонки, 
			// не забыть попробовать запустить с флагом --race, когда выключим мьютекс
			mu.Lock()
			deliveries++ // Критическая секция
			mu.Unlock()
			
			//fmt.Printf("Заказ %d доставлен\n", orderID)
		}(i)
	}

	wg.Wait()
	fmt.Printf("\n Доставлено: %d\n Потеряно: %d\n", deliveries, totalOrders-deliveries)
}
```
##### RW мьютекс
Для чего придумали еще один тип мьютекса?
Когда операций чтения сильно больше чем, операций записи - RW мьютекс может ускорить выполнение программы (за счет того, что при блокировке для чтения - `RLock()`, остальные операции чтения `RLock()` не блокируются).
```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var (
		mu              sync.RWMutex // Защищает счетчик
		deliveredPizzas int         // Счетчик доставленных пицц
		
		wg              sync.WaitGroup
	)

	totalOrders := 5 // Всего заказов

	// 1. Курьеры доставляют пиццу (запись)
	wg.Add(1)
	go func() {
		for i := 0; i < totalOrders; i++ {
			mu.Lock() // Эксклюзивная блокировка для записи
			deliveredPizzas++
			fmt.Printf("Пицца %d доставлена\n", deliveredPizzas)
			mu.Unlock()
			
			time.Sleep(1 * time.Second) // Время на доставку
		}
		wg.Done()
	}()

	// 2. Клиенты проверяют статус (чтение)
	wg.Add(1)
	go func() {
		for {
			mu.RLock() // Разделяемая блокировка для чтения
			current := deliveredPizzas
			mu.RUnlock()

			if current >= totalOrders {
				break
			}

			fmt.Printf("Проверка: доставлено %d/%d\n", current, totalOrders)
			time.Sleep(300 * time.Millisecond) // Частые проверки
		}
		wg.Done()
	}()

	wg.Wait()
	fmt.Println("\nВсе пиццы доставлены!")
}
```
Вопросы про этот тип мьютекса:
- Если вызвать `Lock()` -> после вызов `RLock()` заблокируется?
- Если вызвать `RLock()` -> после вызов `Lock()` заблокируется?
- Если вызвать `RLock()` -> после вызов `RLock()` заблокируется?
- Если вызвать `Lock()` ->  после вызов `Lock()` заблокируется?

#### Атомарные операции (`sync/atomic`)
Чаще всего применяются для каких-либо счетчиков, которые инкрементируюся в разных горутинах

```go
var counter int32
atomic.AddInt32(&counter, 1) // Без блокировок
```

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var deliveries int32
	var wg sync.WaitGroup

	totalOrders := 1000 // Всего заказов на доставку пиццы
	wg.Add(totalOrders)

	fmt.Println("Доставок пиццы ожидается:", totalOrders)

	// Запускаем курьеров
	for i := 0; i < totalOrders; i++ {
		go func(orderID int) {
			defer wg.Done()
			
			//deliveries++ // Критическая секция
			atomic.AddInt32(&deliveries, 1) // Критическая секция
			
			//fmt.Printf("Заказ %d доставлен\n", orderID)
		}(i)
	}

	wg.Wait()
	fmt.Printf("\n Доставлено: %d\n Потеряно: %d\n", deliveries, totalOrders-int(deliveries))
}

```

### Вопрос - как мы можем избежать гонки данных без изменения кода?

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var deliveries int
	var wg sync.WaitGroup

	totalOrders := 1000 // Всего заказов на доставку пиццы
	

	fmt.Println("Доставок пиццы ожидается:", totalOrders)

	wg.Add(totalOrders)
	// Запускаем курьеров
	for i := 0; i < totalOrders; i++ {
		go func(orderID int) {
			defer wg.Done()
			
			deliveries++ // Критическая секция
			
			//fmt.Printf("Заказ %d доставлен\n", orderID)
		}(i)
	}

	wg.Wait()
	fmt.Printf("\n Доставлено: %d\n Потеряно: %d\n", deliveries, totalOrders-deliveries)
}
```

> [!question]- Возможно ли так сделать?
> Да. Но нужно как то сделать код не параллельным 
> (\* Как думаете не параллельный код может быть конкурентным?)

> [!answer]- Подробнее
> Можно задать переменную GOMAXPROCS=1, которая ограничивает приложение одним системным потоком.
> Сейчас по умолчанию она равно количеству логических ядер в системе. В go это чило можно узнать, вызвав `runtime.NumCPU()`
> Подробности
> - Не ограничивает количество горутин: Горутины по-прежнему работают конкурентно, но параллелизм (одновременное выполнение на разных ядрах CPU) зависит от `GOMAXPROCS`.
> - Избыточное значение**: Установка значения больше, чем количество CPU, может привести к частым переключениям контекста и снижению производительности.
> - Влияние на блокирующие операции: Если горутины часто блокируются (например, I/O), увеличение `GOMAXPROCS` может улучшить производительность.
 
### Паттерны, которые изучим на следующей практической работе
   - **for-select**: Обработка каналов в цикле
   - **done-канал**: Прерывание длительных операций  
   -  **FanIn, FanOut**: Из многих в один и из одного в многие каналы
   - **Worker Pool**: Распределение задач через каналы
   И еще несколько важных и полезных на практике решений в коде

---
### Итог
- **Каналы > Мьютексы**: Предпочитайте обмен сообщениями через каналы.  
- **Закрывайте горутины явно**: Через контексты или `done`-каналы (разберем на практическом занятии).  
- **Избегайте преждевременной оптимизации**: Начинайте с простых небуферизированных каналов.  
- **Тестируйте на гонки**: `go test -race` (флаг race можно передавать команды go run и при сборке через `go build -race` - в таком случае race detector будет включен в скомпилированной программе).

### Дополнительные материалы
- Большой сборник материалов на go wiki (очень рекомендую посмотреть) - https://go.dev/wiki/LearnConcurrency
- Статья от Николая Тузова про то как планировщик управляет горутинами - https://habr.com/ru/articles/891426/
- Статья с материалами по теме (вышла как раз на следующий день после лекции): Разбираем конкурентность в Go: книги, блоги, выступления - https://habr.com/ru/companies/yadro/articles/892632/
- Статья про атомики и немного про их внутреннее устройство - https://habr.com/ru/articles/744822/
- Статья от Антоная Жиянова Возможные ошибки при применении атомиков - https://antonz.ru/atomics-composition/

