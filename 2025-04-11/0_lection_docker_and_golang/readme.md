---
date_created: "202504102224"
tags: 
licence: See LICENCE.md in root of this repository
author: Зайнутдинов Тимур Маратович
---

# Практическое занятие - Docker и Golang

Контейнеризация Golang-приложений с помощью Docker является стандартной практикой в современной разработке. На занятии мы рассмотрим приемы созданию `Dockerfile`, `docker-compose.yml`, включая оптимизацию размера образа через многоэтапные сборки, какие образы можно применять для сборки конечного образа, немного о безопасности (выполнение не от root), оптимизации конечного бинарника, добавлении в бинарный файл дополнительной информации такой как версия приложения. Применение этих практик позволяет уменьшить размер образов, ускорить процесс сборки и усилить безопасность.

## Многоэтапная сборка (Multi-stage builds)

Многоэтапная сборка является одной из наиболее эффективных и часто применяемых практик при написании `Dockerfile` для Go-приложений. Этот подход позволяет значительно уменьшить размер итогового образа путем разделения процесса сборки на несколько этапов.

### Преимущества и принцип работы

Основное преимущество многоэтапной сборки заключается в том, что инструменты и зависимости, необходимые только для сборки приложения, не попадают в конечный образ. Это особенно важно для Go-приложений, так как компилятор и полный набор инструментов разработки занимают значительное пространство, но не нужны для запуска скомпилированного бинарного файла.

### Пример базового Dockerfile с многоэтапной сборкой
```Dockerfile
# Этап сборки
FROM golang:1.24-alpine AS builder
RUN apt update && apt install make
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN make build

# Этап создания конечного образа
FROM alpine:latest
WORKDIR /app/
COPY --from=builder /app/app .
CMD ["./app"]
```

В этом примере первый этап использует образ `golang:1.24-alpine` для сборки приложения, а второй этап берет только скомпилированный бинарный файл и помещает его в минимальный образ `alpine`.

### Варианты базовых образов для конечного образа

Для этапа сборки конечного образа есть несколько вариантов базовых образов:
1. **alpine** - легковесный Linux-образ, который содержит минимальный набор утилит.
2. **scratch** - пустой образ, который не содержит операционной системы, подходит только для полностью статичных (которые не используют биндинги к `glibc => CGO`) бинарных файлов. Это самый маленький возможный вариант.
3. **distroless** - минималистичные образы от Google, содержащие только необходимые зависимости без shell или пакетного менеджера. 
```Dockerfile
# Этап создания конечного образа
FROM gcr.io/distroless/static-debian12
COPY --from=builder /app /app
ENTRYPOINT ["/app/app"]
```

Обычно в практике так: 
- debian, ubuntu, etc - для разработки и если нужна CGO и glibc
- alpine - для разработки, если не нужна CGO и glibc
- scratch - для прода, если не нужна CGO и glibc
- distroless - для прода, если нужны какие то зависимости от операционной системы, но при этом для безопасности исключаются встроенные приложения ОС 

## Оптимизация и кэширование в Dockerfile

Правильная структура `Dockerfile` значительно влияет на скорость сборки и эффективность использования кэша Docker.

### Кэширование зависимостей

Один из ключевых приемов — отдельное копирование и загрузка Go модулей перед копированием всего исходного кода:

```Dockerfile
COPY go.mod go.sum ./
RUN go mod download
COPY . .
```

Такой подход обеспечивает, что зависимости будут загружены только при изменении файлов `go.mod` или `go.sum`, а не при каждом изменении исходного кода. Это значительно ускоряет последующие сборки.

### Оптимизация c использованием флагов компиляции

Для оптимизации размера бинарного файла рекомендуется использовать следующие флаги при компиляции:

```Dockerfile
RUN CGO_ENABLED=0 go build -ldflags="-w -s" -o main .
```

- `CGO_ENABLED=0` отключает CGO, что делает бинарный файл статическим и не зависящим от библиотек C (Конечно если вы или пакеты-зависимости не используете в коде. Вы в 99% случаев не будете использовать CGO.)
- `-ldflags="-w -s"` удаляет таблицу символов и отладочную информацию, уменьшая размер бинарного файла, для прода чаще всего. А вот для разработки удобно их оставлять и выполнять удаленную отладку.

### Использование `.dockerignore`

Создание файла `.dockerignore` исключает ненужные файлы из контекста сборки, что ускоряет процесс и уменьшает размер образа:

`.dockerignore`

```.dockerignore
.git
build/
.env
Dockerfile
docker-compose.yml
```

## Docker Compose для разработки и производственного окружения

### Docker Compose для среды разработки

В среде разработки часто требуется автоматическая перезагрузка приложения при изменении кода. Для этого можно использовать инструменты вроде `air` - https://github.com/air-verse/air:

```yaml
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    volumes:
      - ./:/app # Тут пробрасываем папку с исходным кодом нашего приложения
```

Важный момент здесь - монтирование как тома (`volumes`), что позволяет видеть изменения в коде в реальном времени без необходимости пересборки образа - пересобирается лишь само приложение с помощью `air`.

### Различные профили для разработки и продакшена

`docker compose` поддерживает разделение сервисов на профили, что позволяет определять разные группы контейнеров для разработки и продакшена:

```yaml
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    profiles: ["prod"]
  
  app-dev:
    build:
      context: .
      dockerfile: Dockerfile.dev
    volumes:
      - ./:/app
    profiles: ["dev"]
```

Запуск определенного профиля осуществляется командой:

```bash
docker-compose --profile dev up
```


### Структура проекта и расположение файлов

Для организации файлов Docker в проекте чаще всего используется следующий подход: 
Расположение файлов Docker в **корневом уровне** - наиболее распространенный подход, где `Dockerfile` и `docker-compose.yml` размещаются в корне проекта.
Иногда еще располагают в подпапках, но такое вижу довольно редко.

## Безопасность

### Запуск без root-привилегий

Для повышения безопасности рекомендуется запускать приложение не от имени root-пользователя (для образов с ОС, типа alpine или distroless):

```Dockerfile
USER nobody:nobody
```

Даже при использовании образа `scratch` можно указать пользователя. Нужно лишь на первой стадии с образом, основанном на ОС, добавить пользователя и скопировать `/etc/passwd` из него. :

```Dockerfile
COPY --from=build /etc/passwd /etc/passwd  
USER nobody:nobody
```

Кстати, таким же образом можно скопировать корневой сертификат из стадии сборки в стадию конечного образа - когда приложение работает с SSL сертификатами.
```Dockerfile
# Этап создания конечного образа
COPY --from=build /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
```
### Минимизация слоев

Для уменьшения количества слоев в образе рекомендуется объединять несколько команд `RUN` в одну с использованием оператора `&&`:

```Dockerfile
RUN apk add --no-cache git && \
    go mod download && \
    go build -o main .
```

Это улучшает скорость сборки образа и уменьшает размер образа.


## Статические анализаторы для проверки Dockerfile и кода на уязвимости (CVE) и другие инструменты
### Hadolint
https://github.com/hadolint/hadolint
Написан на haskell.
Больше предназначен для следования хорошим практикам написания `Dockerfile`.
Пример базового применения (взял из `readme.md` репозитория проекта)
```shell
docker run --rm -i hadolint/hadolint < Dockerfile
```

### Trivy
https://github.com/aquasecurity/trivy
Написан на golang.
Проверяет не только `Dockerfile`, но и другие аспекты безопасности, в том числе сканирует на наличие  доступных секретов.
Есть плагины для ide, в том числе для goland и vscode.

> Эти инструменты часто включают в прекоммит хуки и пайплайны CI/CD.

### Dive - не линтер, но удобный инструмент для изучения образов
https://github.com/wagoodman/dive
Написан на golang.
Позволяет анализировать слои образа докер - наглядно показывает внесенные изменения.
Можно смотреть статистику про образу.
```shell
go install github.com/wagoodman/dive@latest
```

### Команды docker для получения дополнительной информации о контейнерах и образах

Подробная информация об объектах docker
```shell
docker inspect
```

Получить список образов с дополнительной информацией (например, размер образа)
```shell
docker images ls 
```

Запущенные контейнеры (флаг `-a` для получения всех контейнеров на машине)
```shell
docker ps 
```

## Удаленная отладка
Приложение запускается в docker контейнере (через `delve`), но к нему можно подключиться через ide с `delve`.

> delve - отладчик для языка go, написан на go, все ide с возможностью отладки кода на go используют его (другого не встречал).
> https://github.com/go-delve/delve

```Dockerfile
# Этап сборки  
FROM golang:1.24-alpine AS builder  
RUN apk update --no-cache && \  
    apk add make git  
WORKDIR /app  
RUN mkdir -p db/sqlite  
COPY go.mod go.sum ./  
RUN go mod download  
RUN go install github.com/go-delve/delve/cmd/dlv@v1.24.2  
COPY . .  
RUN make build_debug  
  
  
# Этап создания конечного образа  
FROM alpine:3.21  
#USER nobody:nobody # Без спойлеров - поэтому пользователь не используется  
WORKDIR /app  
COPY --from=builder /go/bin/dlv .  
COPY --from=builder /app/build/app .  
COPY --from=builder /app/db/sqlite ./db/sqlite  
# После "--" идут аргументы приложения  
CMD ["./dlv", "exec", "./app", "--headless", "--listen=:2345", "--api-version=2", "--"]
```

## Дополнительные материалы
1. Про создание из scratch образа и выполнение не от root через добавление пользователя (англ) - https://medium.com/@lizrice/non-privileged-containers-based-on-the-scratch-image-a80105d6d341

### Для отладки кода в vs-code

Файл `launch.json` в папке `.vscode` (например, в папке проекта)
```json
{
  "version": "0.0.1",
  "configurations": [
    {
      "name": "Remote debug",
      "type": "go",
      "mode": "remote",
      "request": "attach",
      "host": "127.0.0.1",
      "port": 2345
    }
  ]
}
```

### Полезные команды, которые применим на занятии

#### Скопировать файл из контейнера
```shell
 docker cp <имя контейнера>:/etc/group ./group
```

#### Подключиться к контейнеру - запустить шелл (при наличии в образе)
```shell
docker exec -it <имя контейнера> /bin/sh
```