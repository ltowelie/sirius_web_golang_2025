---
date_created: "202503050602"
licence: "See LICENCE.md in root of this repository"
author: "Зайнутдинов Тимур Маратович"
---

#  Практическое занятие simple http server

### Работа по git flow (совсем кратко, так как скорее всего уже знаете)
- Создаем репозиторий с веткой `master`. Обычно ветка защищена от мержа большинству пользователей. Обычно в мержить в эту ветку может ограниченное число лиц. Чаще всего эта ветка отражает текущее состояние прода.
- От ветки `master` создаем ветку `develop` - ветка куда будут вливаться все фичи, фиксы. Из этой ветки изменения мержатся в ветку master.
- От ветки `develop` создаются ветки с префиксом `feature/<краткое название фичи>` и `fix/<краткое название фикса>`. После написания и тестирования фичи/фикса - создается merge request (pull request если речь о github). 
Обычно после создания merge request код проходит проверку коллегами - code review.

feature (фича) - что то новое в функионале сервиса
fix (фикс) - исправление какой либо ошибки в коде сервиса

### Создаём репозиторий
- Создайте папку в домашней директории (назовите по своему усмотрению, например projects)
```shell
mkdir ~/projects
```
- Создайте папку проекта (например 00_practice_day)
```shell
mkdir -P ~/projects/00_practice_day
```
- Перейдите в нее и инициализируйте пустой репозиторий 
```shell
cd ~/projects/day01
git init
```
(если репозиторий уже есть в системе контроля версий, например в gitverse, github, gitlab - то лучше склонировать)
```shell
git clone <путь к удаленному репозиторию> ~/00_practice_day
```
- По умолчанию при создании репозитория создается ветка master
```shell
git branch --show-current 
# master
```
- Создаем ветку develop и далее ветку feature/init (скорее зависит от процессов компании, иногда первый коммит сразу в develop делают)
```shell
git checkout -b develop
git checkout -b feature/init
```
Будем работать в этой ветке


### Базовый сервер с использованием стандартной библиотеки
```go
package main 

import (
	"fmt"
	"net/http"
)

func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Привет, мир!")
})

	http.ListenAndServe(":8080", nil)
}
```
Краткое объяснение

- Регистрация обработчика:
```go
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Привет, мир!")
    })
```
- `http.HandleFunc()` регистрирует функцию-обработчик для пути `/` (корневая страница).
- При обращении к этому пути выполняется анонимная функция с двумя параметрами:
  - `w http.ResponseWriter` — объект для отправки HTTP-ответа
  - `r *http.Request` — информация о входящем запросе
- `fmt.Fprintf(w, ...)` отправляет строку "Привет, мир!" в ответ на запрос.

- Запуск сервера:
```go
    http.ListenAndServe(":8080", nil)
}
```
- Запускает HTTP-сервер на порту 8080.
- `nil` означает, что используется стандартный роутер (который мы настроили через `HandleFunc`).
- Сервер работает бесконечно, пока его не остановят (например через сигнал прерывания - Ctrl+C в терминале).

**Как работает:**
1. При запуске программы (go run main.go) сервер стартует на localhost:8080
2. При переходе в браузере по адресу http://localhost:8080 вы увидите "Привет, мир!"
3. Сервер будет отвечать на все запросы к корневому пути `/` этим сообщением
4. По запросу к другим путям сервер будет автоматически отправлять статус-код 404

### Задачи для самостоятельной работы

#### Инструкции
1. Создайте папку с именем `00_practice_day`
2. Каждую задачу помещаете в отдельную ветку с названием задачи (с префиксом `feature/`)
3. После выполнения задачи мержите в ветку `develop`
4. За основу можете взять код базового `http` сервера

#### Задачи для самостоятельной работы
1. Возьмите за основу базовый сервер. Добавьте его в свой репозиторий по методике, которую описал выше (в ветку develop).
2. Напишите эхо обработчик, который возвращает тело переданного ему запроса. Эндпойнт `/echo`, метод `post`. 
3. Напишите обработчик, который возвращает текущее время. Эндпойнт `/time`, метод `get`
	- Ответ в виде JSON строки `{"time": "2025-03-05 15:23:01"}`
	- Заголовок ответа `Content-type` должен быть `application/json`
4. Напишите обработчик, который по эндпоинту `/greeting` принимает запрос с параметром `name` и возвращает строку. 
	- Реализовать проверку типа запроса - если будет не `GET` - отправлять 405 код
	- Реализовать проверку на заполненность параметра `name` - если не заполнен, возвращать статус 400 и в теле ответа написать, что поле `name` обязательно
5. Добавьте загрузку параметров из переменных окружения (host и port)


